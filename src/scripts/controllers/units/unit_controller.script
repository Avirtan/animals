local world_ecs = require "src.ecs.world_ecs"
local collision_component = require "src.ecs.components.physics.collision_component"
local physics_service = require "src.services.physics_service"

go.property("url_sprite", msg.url())
go.property("entity_id", -1)

function init(self)
	self.current_url = msg.url()
	self.id_model    = nil
	-- self.correction  = vmath.vector3()
end

function update(self, dt)
	-- reset correction
	-- self.correction = vmath.vector3()
end

function on_message(self, message_id, message, sender)
	local is_physic_event = physics_service.is_physic_message(message_id)
	if is_physic_event then
		--- @type CollisionComponent
		local component = world_ecs.get_component(world_ecs.world_id.Main, self.entity_id, collision_component.name)
		collision_component.set_collision(component, message_id, message)
	end

	if message_id == hash("trigger_response") then
		-- Get the info needed to move out of collision. We might
		-- get several contact points back and have to calculate
		-- how to move out of all of them by accumulating a
		-- correction vector for this frame:
		-- if message.distance > 0 then
		-- 	-- First, project the accumulated correction onto
		-- 	-- the penetration vector

		-- 	if message.distance < 0.02 then
		-- 		print(message.distance)
		-- 	end
		-- 	local proj = vmath.project(self.correction, message.normal * message.distance)
		-- 	if proj < 1 then
		-- 		-- Only care for projections that does not overshoot.
		-- 		local comp = (message.distance - message.distance * proj) * message.normal
		-- 		-- Apply compensation
		-- 		go.set_position(go.get_position() + comp)
		-- 		-- Accumulate correction done
		-- 		self.correction = self.correction + comp
		-- 	end
		-- end
	end
end
