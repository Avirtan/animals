local anim_service = require "src.services.characters.animation_service"
local events_service = require "src.services.events_service"
local screen_service = require "src.services.screen_service"
local inputService = require "src.services.input_service"

go.property("speed", 0)
go.property("url_animation", msg.url())

--- @class astar_move
--- @field target_point vector3
--- @field dir vector3
--- @field points table
--- @field paths table
--- @field animation_data_event table
--- @field speed number
--- @field url_animation url

--- @param self astar_move
local function resetMove(self)
    self.target_point.x = 0
    self.target_point.y = 0
    for index, idPoint in ipairs(self.points) do
        go.delete(idPoint)
        self.points[index] = nil
    end
    for index, idPoint in ipairs(self.paths) do
        self.paths[index] = nil
    end
    self.dir.x = 0
    self.dir.y = 0
end

--- @param self astar_move
function init(self)
    self.dir                  = vmath.vector3(0, 0, 0)
    self.paths                = {}
    self.target_point         = vmath.vector3()
    self.animation_data_event = {
        x = 0,
        y = 0
    }
    self.points               = {}
end

--- @param self astar_move
function update(self, dt)
    if self.dir.x ~= 0 or self.dir.y ~= 0 then
        local pos = go.get_position()
        pos = pos + self.dir * self.speed * dt
        go.set_position(pos)
    end

    if #self.paths > 0 and self.target_point.x == 0 and self.target_point.y == 0 then
        self.target_point.x = self.paths[1]
        self.target_point.y = self.paths[2]
        self.dir = vmath.normalize(self.target_point - go.get_position());
        self.animation_data_event.x = self.dir.x
        self.animation_data_event.y = self.dir.y
        -- msg.post(self.url_animation, events_service.animation_events.change_animation_event, self.animation_data_event)
    end
    if self.target_point.x ~= 0 and self.target_point.y ~= 0 then
        local distance = vmath.length(go.get_position() - self.target_point)
        if distance < 1 then
            self.target_point.x = 0
            self.target_point.y = 0
            self.dir.x = 0
            self.dir.y = 0
            table.remove(self.paths, 1)
            table.remove(self.paths, 1)
            if #self.paths == 0 then
                self.animation_data_event.x = 0
                self.animation_data_event.y = 0
                -- msg.post(self.url_animation, events_service.animation_events.change_animation_event,
                --     self.animation_data_event)
            end
        end
    end
end

--- @param self astar_move
function on_message(self, message_id, message, sender)
    if message_id == events_service.character_events.send_path then
        setPaths(self, message)
    elseif message_id == inputService.events.key then
        resetMove(self)
    end
end

--- @param self astar_move
function setPaths(self, path)
    for index, _ in ipairs(self.paths) do
        self.paths[index] = nil
    end
    local i = 1;
    for _, tile in ipairs(path) do
        local x, y        = screen_service.tile_to_world(tile.x, tile.y);
        self.paths[i]     = x
        self.paths[i + 1] = y
        i                 = i + 2;
    end
    self.target_point.x = 0
    self.target_point.y = 0
end
